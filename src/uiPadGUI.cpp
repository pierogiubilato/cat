//------------------------------------------------------------------------------
// CAT Pad User Interface GUI class											  --
// (C) Piero Giubilato 2011-2024, Padova University							  --
//------------------------------------------------------------------------------

//______________________________________________________________________________
// [File name]		"uiPadGUI.cpp"
// [Author]			"Piero Giubilato"
// [Version]		"1.2"
// [Modified by]	"Piero Giubilato"
// [Date]			"20 Sep 2024"
// [Language]		"c++"
//______________________________________________________________________________

// Application components
#include "uiPadGUI.h"
#include "acLoop.h"
#include "afUtilities.h"

// To be checked for different environments!
#define SDL_MOUSE_WHEEL_STEP 120

// #############################################################################
namespace cat { namespace ui {

// *****************************************************************************
// **							  Static Members							  **
// *****************************************************************************

pad* padGUI::_owner = 0;	// The static reference to the Pad owning the TwBar.


// *****************************************************************************
// **							  Special Members							  **
// *****************************************************************************

//______________________________________________________________________________
padGUI::padGUI(pad* owner)
{
	/*! Creates a pad GUI, basically a set of AntTweakBars and some support
	 *	routines.
	 */
		
	// Set up the parent
	_owner = owner;

	// Startup presets.
	if (initTwBar()) throw std::runtime_error("TwBar initialization failed.");
		
	// Set the mouse/draw utilities.
	_mWheelPos = 0;
	_mArcBall.SetViewportSize(_owner->_window->width(), _owner->_window->height());	
	
	// Layout.
	_barMove = 0;
	layoutSet(kl_Side);
}

//______________________________________________________________________________
padGUI::~padGUI() 
{
	/*! Releases all allocated resources. */
	// Nothing to do here at the moment.		
}


// *****************************************************************************
// **								Private Members							  **
// *****************************************************************************

//______________________________________________________________________________
bool padGUI::initTwBar()
{
	/*! Creates the default TwBars to interact with the 3D environment. */ 

	// Initializes the TwBar systems.
//	TwInit(TW_OPENGL, NULL);
//	TwWindowSize(_Owner->_Window->Width(), _Owner->_Window->Height());
	
	// Pivot bar positon.
	Uint32 pos[2] = {0, 0};	
	Uint32 size[2] = {200, 320};

	// Sets the bars (The help bar is self-added by the TweakBar library). At
	// Startup sets just the initial positions and sizes, to provide a gross
	// positioning for the layout routine to start with.
	
	// Special Help bar, sel-generated by the TwBar system.
//	TwBar* twBar = TwGetBarByIndex(0);
//	TwSetParam(twBar, NULL, "size", TW_PARAM_INT32, 2, size);
//	TwSetParam(twBar, NULL, "position", TW_PARAM_INT32, 2, pos);

	//// The Main bar [_Bar #0, TwBar #1].
	//_bar.push_back(Bar(TwNewBar("tbMain")));
	//	pos[0] = 0; pos[1] = 0;
	//	TwSetParam(_Bar.back()._TwBar, NULL, "position", TW_PARAM_INT32, 2, pos);
	//	TwSetParam(_Bar.back()._TwBar, NULL, "size", TW_PARAM_INT32, 2, size);

	//// The View bar [_Bar #1, TwBar #2].
	//_Bar.push_back(Bar(TwNewBar("tbView")));
	//	pos[0] = 0; pos[1] = size[1];
	//	TwSetParam(_Bar.back()._TwBar, NULL, "position", TW_PARAM_INT32, 2, pos);
	//	TwSetParam(_Bar.back()._TwBar, NULL, "size", TW_PARAM_INT32, 2, size);
	//
	//// The Scene bar [_Bar #2, TwBar #3].	
	//_Bar.push_back(Bar(TwNewBar("tbScene")));
	//	pos[0] = _Owner->_Window->Width() - size[0] ; pos[1] = 0;
	//	TwSetParam(_Bar.back()._TwBar, NULL, "position", TW_PARAM_INT32, 2, pos);
	//	TwSetParam(_Bar.back()._TwBar, NULL, "size", TW_PARAM_INT32, 2, size);

	//// The GP bar [_Bar #4, TwBar #5].	
	//_Bar.push_back(Bar(TwNewBar("tbGP")));
	//	pos[0] = _Owner->_Window->Width() - size[0] ; pos[1] = size[1];
	//	TwSetParam(_Bar.back()._TwBar, NULL, "position", TW_PARAM_INT32, 2, pos);
	//	TwSetParam(_Bar.back()._TwBar, NULL, "size", TW_PARAM_INT32, 2, size);
	//	
	//// The spot view menu bar [_Bar #5, TwBar #6].	
	//_Bar.push_back(Bar(TwNewBar("tbSpot")));
	//	pos[0] = _Owner->_Window->Width() / 2; pos[1] = _Owner->_Window->Height() / 2;
	//	TwSetParam(_Bar.back()._TwBar, NULL, "position", TW_PARAM_INT32, 2, pos);
	//	TwSetParam(_Bar.back()._TwBar, NULL, "size", TW_PARAM_INT32, 2, size);
	//
	//// Global definitions (for every bar).
	//TwDefine("GLOBAL iconalign=horizontal");	// Iconezed alignement.
		
	// Fills the bars.
	updateBars();

	// Everything ok.
	return false;
}


// *****************************************************************************
// **							User interface update						  **
// *****************************************************************************

//______________________________________________________________________________
void padGUI::updateTwBar()
{
	/*! Updates the whole TwBar system. */

	// Reset the TwBar for the new size.
//	TwWindowSize(_Owner->_Window->Width(), _Owner->_Window->Height());
}

//______________________________________________________________________________
void padGUI::updateBars()
{
	/*! Updates all the bars of the GUI. */
	updateBarMain();
	updateBarScene();
	updateBarGP();
	updateBarView();
	updateBarSpot(false);
	updateBarHelp();
}

//______________________________________________________________________________
void padGUI::updateBarMain()
{
	/*! Updates the main TwBar. Adds command buttons, scenes list, memory label
	 *	and all the other gadgets.
	 */

	//// General properties.
	//TwDefine("tbMain label='Pear' valueswidth=60");
	//TwDefine("tbMain resizable=true visible=true iconifiable=true movable=true");
	//TwDefine("tbMain color='0 0 0' alpha=128 text=light");
	//
	//// Sets and cleans the bar to work with.
	//TwBar* twBar = _Bar[0]._TwBar;
	//TwRemoveAllVars(twBar);
	//
	//// Here we show the current scene (if any).
	//static std::string currName("No scene selected");
	//if (_Owner->_Scene[0]) currName = _Owner->_Scene[0]->Name();
	//std::stringstream varParam;
	//varParam << "label='" << currName << "'";
	//TwAddVarRO(twBar, "GP_0", TW_TYPE_STDSTRING, &currName, varParam.str().c_str()); 		
	//
	//// Prepares scene list separator.
	//TwAddSeparator(twBar, NULL, NULL);
	//if (_Owner->_Scene.size() == 1) {
	//	TwAddVarRO(twBar, "info_0", TW_TYPE_STDSTRING, &currName, "label='No scene available'"); 			
	//}

	//// Here we list all the available scenes (scenes list).
	//for (Uint64 i = 1; i < _Owner->_Scene.size(); i++) {
	//	
	//	// Sets entry name and parameters.
	//	std::stringstream varName;
	//	std::stringstream varParam;
	//	varName << "GP_" << i;// << " [" << _Scene[i]->Name() << "]"; 
	//	varParam << "label='" << _Owner->_Scene[i]->Name() << "'";
	//	
	//	// Adds the entry.
	//	TwAddButton(twBar, varName.str().c_str(), cbkMainScene, (void*)i, varParam.str().c_str()); 
	//}

	//// Global command buttons.
	//TwAddSeparator(twBar, NULL, NULL);
	//TwAddButton(twBar, "cmd_Dump", cbkMain, (void*)ktbb_main_Dump, "label='Dump scene'"); 
	//TwAddButton(twBar, "cmd_Save", cbkMain, (void*)ktbb_main_Save, "label='Save scene'"); 
	//TwAddButton(twBar, "cmd_Close", cbkMain, (void*)ktbb_main_Close, "label='Close scene'");
	//TwAddSeparator(twBar, NULL, NULL);
	//TwAddButton(twBar, "cmd_Test", cbkMain, (void*)ktbb_main_Test, "label='Boxes test'");
	//TwAddButton(twBar, "cmd_Test1000", cbkMain, (void*)ktbb_main_Test1000, "label='Boxes test * 1000'");
	//TwAddButton(twBar, "cmd_About", cbkMain, (void*)ktbb_main_About, "label='About Pear'");
	//TwAddButton(twBar, "cmd_Quit", cbkMain, (void*)ktbb_main_Quit, "label='Quit Pear'");
	//
	//// Global Informations.
	//TwAddSeparator(twBar, NULL, NULL);
	//TwAddVarRO(twBar, "info_GPsCount", TW_TYPE_UINT32, &_Owner->_GPsCount, "label='Scene Gps' group='Info'");
	//TwAddVarCB(twBar, "info_GPsSize", TW_TYPE_FLOAT, NULL, pad_GUI::cbkSizeGet, _Owner, "label='Scene size (MBytes)' precision=2 group='Info'");	
	//
	//// Layout mode enums.
	//const TwEnumVal layoutMode[] = {
	//	{kl_Free, "Free"}, {kl_Side, "Side"}
 //   };
	//const TwType type = TwDefineEnum("LayoutMode", layoutMode, SDL_arraysize(layoutMode));

	//// Layout mode callbacks.
	//TwAddVarCB(twBar, "Layout mode", type, pad_GUI::cbkLayoutSet, pad_GUI::cbkLayoutGet, this, "group='Options'");
}

//______________________________________________________________________________
void padGUI::updateBarView()
{
	/*! Updates the view bar with the current view. */ 
	
	//// General properties.
	//TwDefine("tbView label='View' valueswidth=60");
	//TwDefine("tbView resizable=true visible=true iconifiable=true movable=true");
	//TwDefine("tbView color='0 0 0' alpha=128 text=light");
	//	
	//// Select the View properties bar.
	//Bar& cBar = _Bar[1];

	//// Save the actual bar status. 
	//cBar.StatusGet();
	//cBar.StatusSave(); 
	//
	//// Now clean the bar.
	//cBar.Clear();

	//// Checks if the currently selected Scene makes any sense.
	//if (!_Owner->_Scene[0]) return;
	//
	//// Ask the current View to fill the bar.
	//_Owner->_View[0]->uiBarLoad(cBar); 
	//
	//// Match the new bar appearance with the svaed one.
	//cBar.StatusMatch();
	//cBar.StatusSet();
}

//______________________________________________________________________________
void padGUI::updateBarScene()
{
	/*! Fills the Scene bar with the scene's GPs list. If \c gpHnd has non-zero
	 *	value, keeps that GP expanded after refreshing the bar.
	 */ 

	//// General properties.
	//TwDefine("tbScene label='Scene' valueswidth=60");
	//TwDefine("tbScene resizable=true visible=true iconifiable=true movable=true");
	//TwDefine("tbScene color='0 0 0' alpha=128 text=light");
	//
	//// Check if there is any selected scene.
	//if (!_Owner->_Scene[0]) return;

	//// Select the GP properties bar.
	//Bar& cBar = _Bar[2];
	//TwBar* twBar = cBar._TwBar;

	//// Clean and title the bar.
	//cBar.Clear();
	//std::stringstream title;
	//title << "Scene" << " - " << _Owner->_Scene[0]->Name();
	//TwSetParam(twBar, NULL, "label", TW_PARAM_CSTRING, 1, title.str().c_str());
	//	
	//// Refresh.
	//for (Uint64 i = 1; i < _Owner->_Scene[0]->gp_Size(); i++) {
	//	GP* gp = _Owner->_Scene[0]->gp_Get(i);
	//	if (gp) gp->modeParsed(false);
	//}

	//// Pivot crawling vars.
	//GP* gp;
	//GP* gpChild;
	//GPHnd gpIdx = 1;
	//GPHnd gpLevel = 0;
	//
	//// Pivot vars to define the TwBar control strings.
	//std::stringstream varName;
	//std::stringstream varParam;
	//std::string varExp[3] = {"", "[+] ","[-] "};
	//int varExpMode = 0;

	//// Crawl trought all scene the tree branches.
	//while (gpIdx < _Owner->_Scene[0]->gp_Size())	 {
	//	
	//	// Retrieve the GP, skip if a dead one.
	//	gp =_Owner->_Scene[0]->gp_Get(gpIdx);
	//	if (!gp) continue;
	//			
	//	// Add the entry in case
	//	if (gp->modeParsed() == false) {
	//		
	//		// Sets name and parameter for the entry.
	//		varName.str(std::string());
	//		varName << "GP_" << gpIdx;
	//		
	//		// Expansion.
	//		if (gp->child_Count()) {
	//			if (gp->modeExpanded()) varExpMode = 2;
	//			else varExpMode = 1; 
	//		} else varExpMode = 0;	
	//		
	//		// Define variable parameters.
	//		varParam.str(std::string());
	//		varParam << "label='" << std::string(3 * gpLevel, ' ') << varExp[varExpMode] << gp->Name() << "'";
	//			
	//		// Adds the entry to the bar.
	//		TwAddButton(twBar, varName.str().c_str(), cbkSceneGP, (void*)gpIdx, varParam.str().c_str());
	//				
	//		// Flag it as already displayed.
	//		gp->modeParsed(true);
	//	}
	//			
	//	// If expanded plus there is any child still to explore, do it!
	//	Uint64 cIdx = gp->child_Count();
	//	if (gp->modeExpanded()) {
	//		for (cIdx = 0; cIdx < gp->child_Count(); cIdx++) { 
	//			gpChild = _Owner->_Scene[0]->gp_Get(gp->child_Get(cIdx));
	//			if (gpChild->modeParsed() == false) {
	//				gpIdx = gp->child_Get(cIdx);	
	//				gpLevel++;
	//				break;					
	//			}
	//		}
	//	}
	//	
	//	// If no more children...
	//	if (cIdx >= gp->child_Count()) {
	//	
	//		// By default, returns to the parent position.
	//		if (gp->Parent()) {gpIdx = gp->Parent(); gpLevel--;}
	//	
	//		// Or jump to the next parentless item.
	//		else {
	//			gpIdx++;
	//			while (gpIdx < _Owner->_Scene[0]->gp_Size()) {
	//				if (!_Owner->_Scene[0]->gp_Get(gpIdx)->Parent()) break; 
	//				gpIdx++;
	//			}
	//		}
	//	}
	//} // LOOP scene[0]->gp_Size, all over the scene tree.
}

//______________________________________________________________________________
void padGUI::updateBarGP(GPHnd gpHnd)
{
	/*! Fills the GP bar with the currently selected GP. Actually the filling
	 *	happens directly into the GP (and derivatives) itself, this way being 
	 *	possible through overloading to differentiates the setting for every GPs. 
	 *	Here we take care of group management and general arrangements.
	 */ 
		
	//// General properties.
	//TwDefine("tbGP resizable=true valueswidth=60 label='Primitive'");
	//TwDefine("tbGP color='0 0 0' alpha=128 text=light");
	//	
	//// Select the GP properties bar.
	//Bar& cBar = _Bar[3];

	//// Save the actual bar status. 
	//cBar.StatusGet();
	//cBar.StatusSave(); 
	//
	//// Now clean the bar.
	//cBar.Clear();
	//std::stringstream title;
	//title << "Primitive";
	//TwSetParam(cBar._TwBar, NULL, "label", TW_PARAM_CSTRING, 1, title.str().c_str());

	//// Checks if the currently selected Scene and GP make any sense.
	//if (!_Owner->_Scene[0]) return;
	//GP* gp = _Owner->_Scene[0]->gp_Get(gpHnd);
	//if (!gp) return;
	//
	//// Ask the current GP to fill the bar.
	//gp->uiBarLoad(cBar); 
	//
	//// Match the new bar appearance with the saved one.
	//cBar.StatusMatch();
	//cBar.StatusSet();

	//// Updates title.
	//title << " - " << gp->Stem();
	//TwSetParam(cBar._TwBar, NULL, "label", TW_PARAM_CSTRING, 1, title.str().c_str());
}

//______________________________________________________________________________
void padGUI::updateBarSpot(const bool& show)
{
	/*! Updates the popup view bar by adjusting its on-screen position 
	 *	accordingly to the last muse click.	Setting \c 'show' to true will
	 *	make the bar visible, to false will hide it.
	 */ 
	
	//// Select the GP properties bar.
	//Bar& cBar = _Bar[4];
	//TwBar* twBar = cBar._TwBar; 
	//
	//// Save the actual bar status. 
	//cBar.StatusGet();
	//cBar.StatusSave(); 
	//
	//// Now clean the bar.
	//cBar.Clear();
	//	
	//// General properties.
	//TwDefine("tbSpot label='Spot view' valueswidth=60");
	//TwDefine("tbSpot resizable=false visible=false iconifiable=false movable=false");
	//TwDefine("tbSpot color='0 0 0' alpha=128 text=light");
	//	
	//// Defines buttons.
	//TwAddButton(twBar, "cmd_spot_pan_Selected",	cbkSpot, (void*)ktbb_spot_pan_Selected, "label='Center selected'"); 
	//TwAddButton(twBar, "cmd_spot_pan_Origin",	cbkSpot, (void*)ktbb_spot_pan_Origin,	"label='Center to origin'"); 
	//TwAddSeparator(twBar, NULL, NULL);
	//TwAddButton(twBar, "cmd_spot_zoom_All",		cbkSpot, (void*)ktbb_spot_zoom_All,		"label='Zoom all'");
	//TwAddSeparator(twBar, NULL, NULL);
	//TwAddButton(twBar, "cmd_spot_view_Bottom",	cbkSpot, (void*)ktbb_spot_view_Top,		"label='Bottom view'");
	//TwAddButton(twBar, "cmd_spot_view_Top",		cbkSpot, (void*)ktbb_spot_view_Bottom,	"label='Top view'");
	//TwAddButton(twBar, "cmd_spot_view_Left",	cbkSpot, (void*)ktbb_spot_view_Left,	"label='Left view'");
	//TwAddButton(twBar, "cmd_spot_view_Right",	cbkSpot, (void*)ktbb_spot_view_Right,	"label='Right view'");
	//TwAddButton(twBar, "cmd_spot_view_Front",	cbkSpot, (void*)ktbb_spot_view_Front,	"label='Front view'");
	//TwAddButton(twBar, "cmd_spot_view_Back",	cbkSpot, (void*)ktbb_spot_view_Back,	"label='Back view'");

	//// Checks if the currently selected Scene makes any sense.
	//if (!_Owner->_Scene[0]) return;
	//
	//// Updtase bar position looking at the last viewport mouse click position.
	//Uint32 pos[3] = {0, 0, 0};
	//_mArcBall.posViewGet(pos); 
	//TwSetParam(twBar, NULL, "position", TW_PARAM_INT32, 2, pos);
	//
	//Uint32 size[2] = {160, 210};
	//TwSetParam(twBar, NULL, "size", TW_PARAM_INT32, 2, size);

	//// Switch bar visibility status.
	//Uint32 visible = 0;
	//(show) ? visible = 1 : visible = 0;
	//TwSetParam(twBar, NULL, "visible", TW_PARAM_INT32, 1, &visible);
	//
	//// Match the new bar appearance with the svaed one.
	//cBar.StatusMatch();
	//cBar.StatusSet();
}

//______________________________________________________________________________
void padGUI::updateBarHelp()
{
	/*! Updates the self-generated help bar. This is mostly to set reference
	 *	dimensions in the case no other bar has the focus at startup, the help
	 *	bar hence being used as referenza to shape the layout.
	 */
	
	// Self-generated Help Bar, not included into the UI bar structure.
	//Uint32 pos[3] = {0, 0, 0};
	//Uint32 size[2] = {160, 210};
	
}

//______________________________________________________________________________
Uint32 padGUI::layoutGet() const
{
	/*! Returns the current layout mode. */
	return _layout;
}

//______________________________________________________________________________
void padGUI::layoutSet(const Uint32& mode)
{
	/*! Updates the layout of the pad elements accordingly to the pad size. 
	 *	and the provided \c mode. */
	
	// **** DEBUG ****
	//LayoutSet2(10);

	// Update TwBars window reference.
//	TwWindowSize(_Owner->_Window->Width(), _Owner->_Window->Height());
	
	// Stores the new mode if different from NULL
	if (mode != kl_Null) _Layout = mode;

	// Static to store the old size of the window.
	static int wOldWidth = _owner->_window->width();
	static int wOldHeight = _owner->_window->height();

	// Bars size and position store, plus indexes.
	const int barCount = 5; // Bar #0 is the Self-generated Help bar, the spot bar is not used.
	int* barPos = new int[barCount * 2];	
	int* barSize = new int[barCount * 2];
	int x = 0, y = 0;
		
	// General snapping.
	Uint32 Snap = 10;

	// Get the currently targeted bar.
//	TwBar* refBar = TwGetTopBar();
//	if (!refBar) refBar = TwGetBarByIndex(0);
	int refBarSide = 0;

	// Find reference bar index.
	int refBarIdx = 0;
//	while (TwGetBarByIndex(refBarIdx) != refBar) refBarIdx++;
	
	// Do not consider the refBar as valid wheter absent or being the spot view bar.
	if (refBarIdx > 4) {
		refBarIdx = 0;
//		refBar = TwGetBarByIndex(0);
	}

	// Read curren bars position and size, and snap-constrain them.
	for (int i = 0; i < barCount; i++) {

		// Get bar and references indexes.
		x = i * 2 + 0;
		y = i * 2 + 1;
//		TwBar* twBar = TwGetBarByIndex(i);
		 
		// Get current position and size.
//		TwGetParam(twBar, NULL, "position", TW_PARAM_INT32, 2, &barPos[x]);
//		TwGetParam(twBar, NULL, "size", TW_PARAM_INT32, 2, &barSize[x]);
			
		// Rounds to snap.
		barPos[x] = (int)floor((float)barPos[x] / Snap + 0.5) * Snap;
		barPos[y] = (int)floor((float)barPos[y] / Snap + 0.5) * Snap;
		barSize[x] = (int)floor((float)barSize[x] / Snap + 0.5) * Snap;
		barSize[y] = (int)floor((float)barSize[y] / Snap + 0.5) * Snap;
	}

	// Layoutting in case
	// ------------------

	if (_layout == kl_Side) {

		// Retrieves window dimensions positions.
		int wWidth = _owner->_window->width();
		int wHeight = _owner->_window->height();
	
		// Force the reference bar on the left or right side, choosing the one 
		// the bar is closer to. This is computed against the OLD window size.
		if (barPos[refBarIdx * 2] > (wOldWidth - barPos[refBarIdx * 2] - barSize[refBarIdx * 2])) {
			barPos[refBarIdx * 2] = wWidth - barSize[refBarIdx * 2] - Snap;
			refBarSide = 1;
	
		// Or to the left side otherwise.
		} else {
			barPos[refBarIdx * 2] = Snap;
			refBarSide = 0;
		}
	
		// Now set the other bars on the left or right of the screen, and adapt 
		// their size to the reference bar if on the same side.
		for (int i = 0; i < barCount; i++) {
		
			// Skip the reference bar.
			if (i != refBarIdx) {
			
				// Determine if the bar lays on the left or right side.
				int side = 0;
				if (barPos[i * 2] > (wOldWidth - barPos[i * 2] - barSize[i * 2])) side = 1;
								
				// Adapt its size to the reference bar if on the same side.
				if (refBarSide == side) {
					barSize[i * 2] = barSize[refBarIdx * 2];
				}

				// Enforce alignement.
				if (side == 1) barPos[i * 2] = wWidth - barSize[i * 2] - Snap;
				else barPos[i * 2] = Snap;
			}
		}
	
		// Now the bars are horyzontally aligned and sized correctly,
		// it remains to properly place them vertically. First, order
		// by left, top order.
		
		// Put all the non-iconified bars.
		std::vector<int> barIdx;
		for (int i = 0; i < barCount; i++) {
			
			// Get bar iconification status.
			Uint32 icon = 0;
//			TwBar* twBar = TwGetBarByIndex(i);
//		 	TwGetParam(twBar, NULL, "iconified", TW_PARAM_INT32, 1, &icon);
				
			// Bar is on full display, consider it!
			if (!icon) barIdx.push_back(i);
		}

		// Orders the bar by left-top order
		bool swapped = true;
		while (swapped) {
		
			// Reset swapping.
			swapped = false;
		
			// Swapping cycle
			for (int i = 1; i < barIdx.size(); i++) {
			
				// Get references.
				int xA = barIdx[i-1] * 2 + 0; int yA = barIdx[i - 1] * 2 + 1;
				int xB = barIdx[i] * 2 + 0; int yB = barIdx[i] * 2 + 1;
		
				// Check and swap in case.
				if ((barPos[xA] > barPos[xB]) || (barPos[xA] == barPos[xB] && barPos[yA] > barPos[yB])) {
					int swap = barIdx[i];
					barIdx[i] = barIdx[i - 1];
					barIdx[i - 1] = swap;
					swapped = true;
				}
			}
		}

		// Calculates all other bars positions and sizes accordingly. Notes how bar
		// are here scanned accordingly to their position in the screen.
		for (int i = 0; i < barIdx.size(); i++) {

			// This ensures following the screen ordering.
			int bix = barIdx[i]; 
			
			// First bar Y pos is always on top.
			if (i == 0) barPos[bix * 2 + 1] = Snap;

			// First bar of any side.
			else if (barPos[bix * 2] != barPos[barIdx[i - 1] * 2]) barPos[bix * 2 + 1] = Snap;

			// All other bars.
			else barPos[bix * 2 + 1] = barPos[barIdx[i - 1] * 2 + 1] + barSize[barIdx[i - 1] * 2 + 1] + Snap;
		}
	
	} // End of SIDE layout.
	
	// Assign bars adjusted positions and sizes.
	for (int i = 0; i < barCount; i++) {

		// Get bar and references indexes.
		x = i * 2 + 0;
		y = i * 2 + 1;
		TwBar* twBar = TwGetBarByIndex(i);
	
		// Assign back.
//		TwSetParam(twBar, NULL,	"position", TW_PARAM_INT32, 2, &barPos[x]);
//		TwSetParam(twBar, NULL,	"size", TW_PARAM_INT32, 2, &barSize[x]);
	}

	// Free the store.
	delete[] barPos;
	delete[] barSize;

	// Save current window size.
	wOldWidth = _owner->_window->width();
	wOldHeight = _owner->_window->height();
}

//______________________________________________________________________________
void padGUI::layoutSet2(const Uint32& snap)
{
	/*! Updates the layout of the pad elements accordingly to the pad size. 
	 *	and the provided \c mode. */
	
	// Update TwBars window reference.
//	TwWindowSize(_Owner->_Window->Width(), _Owner->_Window->Height());
	
	// Creates an XY ordered list of all the visible, non iconified bars.
	std::vector<sar> barList;
	bar::sortByXY(_Bar, barList); 
	
	// Gets the currently targeted bar (but avoids the help bar or the spot bar).
//	TwBar* barRef = Bar::PickTop(); 
	
	// No visible bars: exit!
	if (barList.size() < 1) return;

	// If we have a top bar, use it as a reference by forcing it atop the bar list.
	//bar swap;
	//if (barRef) {
	//	for (int i = 0; i < barList.size(); i++) {
	//		if (barList[i]._TwBar == barRef) {
	//			swap = barList[i];
	//			for (int r = i; r > 0; r--) barList[r] = barList[r - 1];
	//			barList[0] = swap;
	//			break;
	//		}
	//	}
	//
	//// Otherwise, the reference bar will be the first bar in the list!
	//} else barRef = barList[0]._TwBar;
	//

	//// Debug.
	//for (int i = 0; i < barList.size(); i++) {
	//	char label[128];
	//	TwBar* tb = barList[i]._TwBar;
	//	TwGetParam(tb, NULL, "label", TW_PARAM_CSTRING, 128, label);
	//	std::cout << "Rank: " << i << " bar #: " << label << "\n";
	//}

}


//______________________________________________________________________________
void padGUI::updateMouse()
{
	/*! Updates mouse tracking boundary conditions (window size, etc.) */

	// Defines new window size.
	_mArcBall.setViewportSize(_owner->_window->width(), _owner->_Window->height());
}


// *****************************************************************************
// **							User interface events						  **
// *****************************************************************************

//______________________________________________________________________________
bool padGUI::evnBar(SDL_Event evn)
{
	/*! This code translates the new events struct provided by SDL 2.x by 
	 *	calling directly the TwBar events handlers, allowing AntTweakBar work 
	 *	with SDL 2.x. It also adds "magnetic" placing to help aligning the bars.
	 */
	
	// Pivot. Result = true will disable further event checking in the main
	// event handler.
	bool result = false;

	// Handle different event types.
	switch (evn.type) {
		case SDL_MOUSEBUTTONUP:	//result = (TwMouseButton(TW_MOUSE_RELEASED, 
								//static_cast<TwMouseButtonID>(evn.button.button)) != 0);
								break;
		
		case SDL_MOUSEBUTTONDOWN:	//result = (TwMouseButton(TW_MOUSE_PRESSED, 
								//static_cast<TwMouseButtonID>(evn.button.button)) != 0);
								break;

		case SDL_MOUSEMOTION:	//result = (TwMouseMotion(evn.motion.x, evn.motion.y) != 0);
								break;
	
		case SDL_MOUSEWHEEL:	_mWheelPos += evn.wheel.y / SDL_MOUSE_WHEEL_STEP;
								//result = (TwMouseWheel(_mWheelPos) != 0);
								break;

		case SDL_KEYDOWN:		//result = (TwKeyPressed(evn.key.keysym.sym, evn.key.keysym.mod) != 0);
								break;   
	}
		
	// Manages bars moving.
	if (_barMove == 0 && result && evn.type == SDL_MOUSEBUTTONDOWN) _barMove = 1;
	else if (_barMove == 1 && result && evn.type == SDL_MOUSEMOTION) _barMove = 2;
	else if (_barMove == 2 && result && evn.type == SDL_MOUSEMOTION) _barMove = 2;
	else if (_barMove == 2 && result && evn.type == SDL_MOUSEBUTTONUP) {
		_barMove = 0;
		layoutSet();
	}
	else _BarMove = 0;

	// Returns if the event was intercepteb by the bar.
	return result;  	
}

//______________________________________________________________________________
bool padGUI::evnMouse(SDL_Event evn)
{
	/*! Handles mouse events. */
  	
	// TEMPORARY
	bool zp = false; // Use right button for pan insted of scale.

	// Handle different event types.
	switch (evn.type) {
		
		// Mouse button down. 	
		case SDL_MOUSEBUTTONDOWN:
						
			// Reset dragging.
			_mDrag = false;

			// Left button.
			if (evn.button.button == SDL_BUTTON_LEFT) {
				
				// In any case, hide the popup view bar.
				updateBarSpot(false);

				// Begin mouse rotation. 									
				_mArcBall.Begin(evn.button.x, evn.button.y, 0, zp, _owner->_view[0]);

				// Switch picking status anyway. If movement will follow, picking info
				// will actually serve only to help optimizing zooming/rotating actions.
				_mPick.Begin(evn.button.x, evn.button.y);
			}
			
			// Right button: starts scaling/panning.
			if (evn.button.button == SDL_BUTTON_RIGHT) {			
				_mArcBall.Begin(evn.button.x, evn.button.y, 1, zp, _owner->_view[0]);
			}
			
			// Event intercepted.
			return false;
						
		// Mouse button realesed. Here we check if any dragging has started
		// after button down: if not, let's start a picking action.
		case SDL_MOUSEBUTTONUP:
			
			// Mouse dragged after button down (so it cannot be a pick).
			if (_mDrag) {
				if (evn.button.button == SDL_BUTTON_LEFT || evn.button.button == SDL_BUTTON_RIGHT) {
					_mArcBall.End();
					_mDrag = false; 
				}
			
			// Mouse didn't drag after button down.
			} else {
				_mArcBall.End(); // Abort eventual balling. 
								
				// Left button, let's change the pick status.
				if (evn.button.button == SDL_BUTTON_LEFT) _mPick.StatusStep();
				
				// Right button, show spot view bar!
				if (evn.button.button == SDL_BUTTON_RIGHT) updateBarSpot(true);
			}

			// Event intercepted.
			return false;
						
		// Mouse Dragging! Keep Tracking   
		case SDL_MOUSEMOTION:
			
			// Set dragging is happening.	
			_mDrag = true;
			
			// Acts dragging.
			if (_owner->_view[0]) _mArcBall.Drag(evn.motion.x, evn.motion.y);
			
			// Event intercepted.
			return false;

		// Mouse wheeling: zoom/unzoom.
		case SDL_MOUSEWHEEL:
			
			// Change scale factor.
			_mArcBall.ScaleChange(0.1f * (evn.wheel.y / SDL_MOUSE_WHEEL_STEP)); 
			return false;
	}
			
	// Everything ok.
	return false;	
}

//______________________________________________________________________________
bool padGUI::evnSelect(const std::vector<gp::GPHnd>& sel)
{
	/*! Handles external (user driven) GPs selections. Return false in case 
	 *	everything fine, true otherwise. 
	 */
	
	// Extract the first item of the selection vector.
	gp::GPHnd gpHnd = 0;
	if (sel.size() > 0) {
		gp::GP* gp = _owner->sceneGet()->gpGet(sel[0]);
		if (gp) gpHnd = gp->handle();
	}
	updateBarGP(gpHnd);
	
	// Everything ok.
	return false;	
}


// *****************************************************************************
// **							 Static Callbacks							  **
// *****************************************************************************

//______________________________________________________________________________
void padGUI::cbkMain(void* bIdx) {
	
	/*! Main callback. Handles all the main bar main buttons.  Note that this 
	 *	function is STATIC, not a member. */

	// 64 bits compatible recasting
	Uint64 arg = (Uint64)bIdx;

	// Select button(command)	
	switch (arg) {
		
		// Dump the current scene (if any).
		case ktbb_main_Dump:	if (_owner->scene_Get(0)) _owner->scene_Get(0)->Dump();
						break;
		// Test.
		case ktbb_main_Test: pear::af::util::testSceneBoxes(1000); break;
		case ktbb_main_Test1000: pear::af::util::testSceneBoxes(1000000); break;

		// About.
		case ktbb_main_About: new pear::ui::splash(5000); break;
		
		// Quit.
		case ktbb_main_Quit: pear::ac::_loop->cmdAppQuit(_owner->idx());
	}
}

//______________________________________________________________________________
void padGUI::cbkMainScene(void* sIdx) {
	
	/*! Main bar callback, Scene selection. Make the scene \c sIdx the current 
	 *	active one. Note that this function is STATIC, not a member. */
	
	// 64 bits compatible recasting
	Uint64 arg = (Uint64)sIdx;
	
	// Select scene.
	_owner->sceneSel(arg);
}

//______________________________________________________________________________
void padGUI::cbkSceneGP(void* arg) {
	
	/*! Scene bar callback, GP selection/expansion. Contraxt/expand the gp 
	 *	\c gpIdx. Note that this function is STATIC, not a member.
	 */
	
	// 64 bits compatible recasting.
	gp::GPHnd gpHnd = (gp::GPHnd)arg;
	gp::GP* gp = _owner->sceneGet()->gpGet(gpHnd);
	
	// Swap the expanded state
	gp->modeExpanded(!gp->modeExpanded());   

	// Select the clicked GP(s).
	_owner->selClear(); 
	_owner->selAdd(gpHnd);

	// Redraw the bar (The GP one is updated through the gp drawing/selection).
	_owner->GUI->updateBarScene();
}

//______________________________________________________________________________
void padGUI::cbkGP(void* gpHnd) {
	
	/*! GP bar callback, GP properties modification. ReBuild the GP Display
	 *	list after every modification. Note that this function is STATIC, not 
	 *	a member.
	 */
	
	// 64 bits compatible recasting
	//GPHnd arg = (GPHnd)gpHnd;

	// Swap the expanded state.
	//_Owner->scene_Get()->gp_Get(arg)->glBuild();   
}

//______________________________________________________________________________
void padGUI::cbkSpot(void* bIdx) {
	
	/*! Spot view callback. Handles all the spot view popup bar buttons.
	 *	Note that this function is STATIC, not a member.
	 */

	// 64 bits compatible recasting
	Uint64 arg = (Uint64)bIdx;

	// Select button(command)	
	switch (arg) {
		
		// Panning.
		case ktbb_spot_pan_Selected:	;break;
		case ktbb_spot_pan_Origin:		;break;

		// Zooming.
		case ktbb_spot_zoom_All:		;break;
		
		// View.
		case ktbb_spot_view_Top:		;break;
		case ktbb_spot_view_Bottom:		;break;
		case ktbb_spot_view_Left:		;break;
		case ktbb_spot_view_Right:		;break;
		case ktbb_spot_view_Front:		;break;
		case ktbb_spot_view_Back:		;break;
	}
}

////______________________________________________________________________________
//void TW_CALL pad_GUI::cbkLayoutSet(const void* value, void* client)
//{
//	/*! Set the layout mode. */
//	static_cast<pad_GUI*>(client)->LayoutSet(*static_cast<const Uint32*>(value));
//}
//		
////______________________________________________________________________________
//void TW_CALL pad_GUI::cbkLayoutGet(void* value, void* client)
//{
//	/*! Get the layout mode. */
//	*static_cast<Uint32*>(value) = static_cast<pad_GUI*>(client)->LayoutGet();
//}
//
////______________________________________________________________________________
//void TW_CALL pad_GUI::cbkSizeGet(void* value, void* client)
//{
//	/*! Get the slected scene size in MBytes. */
//	*static_cast<float*>(value) = static_cast<float>(static_cast<Pad*>(client)->_GPsSize) / 1048576;
//}

// *****************************************************************************
// **						  Private drawing members						  **
// *****************************************************************************

//______________________________________________________________________________
bool padGUI::glDraw()
{
	// Draw the TwBars.
	//glDrawBuffer(GL_FRONT);
//	TwDraw();
/*	
	// Set up the drawing viewport.
	_Owner->GL->glSet(); 
	int wWidth = _Owner->_Window->Width();		// Screen wievport width.
	int wHeight = _Owner->_Window->Height();	// Screen wievport height.
	
	// Bar highlight while moving.
	if (_BarMove == 2) {
		
		// Get current bar position and size.
		TwBar* twBar = TwGetTopBar();
		int barPos[2], barSize[2];
		TwGetParam(twBar, NULL, "position", TW_PARAM_INT32, 2, barPos);
		TwGetParam(twBar, NULL, "size", TW_PARAM_INT32, 2, barSize);
			
		// Draw	lines marking the position of the moving bar.
		Uint32 c1 = 0x2000ffff;
		Uint32 c2 = 0xa000ffff;
		_Owner->GL->glLine(0, barPos[1], barPos[0], barPos[1], c1, c2);
		_Owner->GL->glLine(wWidth, barPos[1], barPos[0] + barSize[0], barPos[1], c1, c2);
		_Owner->GL->glLine(barPos[0], 0, barPos[0], barPos[1], c1, c2);
		_Owner->GL->glLine(barPos[0] + barSize[0], 0, barPos[0] + barSize[0], barPos[1], c1, c2); 	 
		_Owner->GL->glLine(0, barPos[1] + barSize[1], barPos[0], barPos[1] + barSize[1], c1, c2);
		_Owner->GL->glLine(wWidth, barPos[1] + barSize[1], barPos[0] + barSize[0], barPos[1] + barSize[1], c1, c2);
		_Owner->GL->glLine(barPos[0], wHeight, barPos[0], barPos[1] + barSize[1], c1, c2);
		_Owner->GL->glLine(barPos[0] + barSize[0], wHeight, barPos[0] + barSize[0], barPos[1] + barSize[1], c1, c2); 	 
	}

	// Reset OpenGL context.
	_Owner->GL->glReset(); 
*/	
	// Everything fine.
	return false;
}


// #############################################################################
}} // Close namespaces
